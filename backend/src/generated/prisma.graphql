type AggregateCustomer {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductData {
  count: Int!
}

type AggregateProductField {
  count: Int!
}

type AggregateProductTemplate {
  count: Int!
}

type AggregateStockCategory {
  count: Int!
}

type AggregateStockItem {
  count: Int!
}

type AggregateSupplier {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWorksheet {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Customer {
  id: ID!
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  taxNumber: String
  status: Boolean
  note: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  taxNumber: String
  status: Boolean
  note: String
}

input CustomerCreateOneInput {
  create: CustomerCreateInput
  connect: CustomerWhereUniqueInput
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  contactName_ASC
  contactName_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  address_ASC
  address_DESC
  taxNumber_ASC
  taxNumber_DESC
  status_ASC
  status_DESC
  note_ASC
  note_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CustomerPreviousValues {
  id: ID!
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  taxNumber: String
  status: Boolean
  note: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateDataInput {
  name: String
  contactName: String
  email: String
  phone: String
  address: String
  taxNumber: String
  status: Boolean
  note: String
}

input CustomerUpdateInput {
  name: String
  contactName: String
  email: String
  phone: String
  address: String
  taxNumber: String
  status: Boolean
  note: String
}

input CustomerUpdateManyMutationInput {
  name: String
  contactName: String
  email: String
  phone: String
  address: String
  taxNumber: String
  status: Boolean
  note: String
}

input CustomerUpdateOneRequiredInput {
  create: CustomerCreateInput
  update: CustomerUpdateDataInput
  upsert: CustomerUpsertNestedInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput!
  create: CustomerCreateInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  contactName: String
  contactName_not: String
  contactName_in: [String!]
  contactName_not_in: [String!]
  contactName_lt: String
  contactName_lte: String
  contactName_gt: String
  contactName_gte: String
  contactName_contains: String
  contactName_not_contains: String
  contactName_starts_with: String
  contactName_not_starts_with: String
  contactName_ends_with: String
  contactName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  taxNumber: String
  taxNumber_not: String
  taxNumber_in: [String!]
  taxNumber_not_in: [String!]
  taxNumber_lt: String
  taxNumber_lte: String
  taxNumber_gt: String
  taxNumber_gte: String
  taxNumber_contains: String
  taxNumber_not_contains: String
  taxNumber_starts_with: String
  taxNumber_not_starts_with: String
  taxNumber_ends_with: String
  taxNumber_not_ends_with: String
  status: Boolean
  status_not: Boolean
  note: String
  note_not: String
  note_in: [String!]
  note_not_in: [String!]
  note_lt: String
  note_lte: String
  note_gt: String
  note_gte: String
  note_contains: String
  note_not_contains: String
  note_starts_with: String
  note_not_starts_with: String
  note_ends_with: String
  note_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

enum Job {
  EVERYBODY
  FRONTOFFICE
  SALES
  GRAPHICDESIGNER
  OPERATOR
  DECOR
}

scalar Long

type Mutation {
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductData(data: ProductDataCreateInput!): ProductData!
  updateProductData(data: ProductDataUpdateInput!, where: ProductDataWhereUniqueInput!): ProductData
  updateManyProductDatas(data: ProductDataUpdateManyMutationInput!, where: ProductDataWhereInput): BatchPayload!
  upsertProductData(where: ProductDataWhereUniqueInput!, create: ProductDataCreateInput!, update: ProductDataUpdateInput!): ProductData!
  deleteProductData(where: ProductDataWhereUniqueInput!): ProductData
  deleteManyProductDatas(where: ProductDataWhereInput): BatchPayload!
  createProductField(data: ProductFieldCreateInput!): ProductField!
  updateProductField(data: ProductFieldUpdateInput!, where: ProductFieldWhereUniqueInput!): ProductField
  updateManyProductFields(data: ProductFieldUpdateManyMutationInput!, where: ProductFieldWhereInput): BatchPayload!
  upsertProductField(where: ProductFieldWhereUniqueInput!, create: ProductFieldCreateInput!, update: ProductFieldUpdateInput!): ProductField!
  deleteProductField(where: ProductFieldWhereUniqueInput!): ProductField
  deleteManyProductFields(where: ProductFieldWhereInput): BatchPayload!
  createProductTemplate(data: ProductTemplateCreateInput!): ProductTemplate!
  updateProductTemplate(data: ProductTemplateUpdateInput!, where: ProductTemplateWhereUniqueInput!): ProductTemplate
  updateManyProductTemplates(data: ProductTemplateUpdateManyMutationInput!, where: ProductTemplateWhereInput): BatchPayload!
  upsertProductTemplate(where: ProductTemplateWhereUniqueInput!, create: ProductTemplateCreateInput!, update: ProductTemplateUpdateInput!): ProductTemplate!
  deleteProductTemplate(where: ProductTemplateWhereUniqueInput!): ProductTemplate
  deleteManyProductTemplates(where: ProductTemplateWhereInput): BatchPayload!
  createStockCategory(data: StockCategoryCreateInput!): StockCategory!
  updateStockCategory(data: StockCategoryUpdateInput!, where: StockCategoryWhereUniqueInput!): StockCategory
  updateManyStockCategories(data: StockCategoryUpdateManyMutationInput!, where: StockCategoryWhereInput): BatchPayload!
  upsertStockCategory(where: StockCategoryWhereUniqueInput!, create: StockCategoryCreateInput!, update: StockCategoryUpdateInput!): StockCategory!
  deleteStockCategory(where: StockCategoryWhereUniqueInput!): StockCategory
  deleteManyStockCategories(where: StockCategoryWhereInput): BatchPayload!
  createStockItem(data: StockItemCreateInput!): StockItem!
  updateStockItem(data: StockItemUpdateInput!, where: StockItemWhereUniqueInput!): StockItem
  updateManyStockItems(data: StockItemUpdateManyMutationInput!, where: StockItemWhereInput): BatchPayload!
  upsertStockItem(where: StockItemWhereUniqueInput!, create: StockItemCreateInput!, update: StockItemUpdateInput!): StockItem!
  deleteStockItem(where: StockItemWhereUniqueInput!): StockItem
  deleteManyStockItems(where: StockItemWhereInput): BatchPayload!
  createSupplier(data: SupplierCreateInput!): Supplier!
  updateSupplier(data: SupplierUpdateInput!, where: SupplierWhereUniqueInput!): Supplier
  updateManySuppliers(data: SupplierUpdateManyMutationInput!, where: SupplierWhereInput): BatchPayload!
  upsertSupplier(where: SupplierWhereUniqueInput!, create: SupplierCreateInput!, update: SupplierUpdateInput!): Supplier!
  deleteSupplier(where: SupplierWhereUniqueInput!): Supplier
  deleteManySuppliers(where: SupplierWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createWorksheet(data: WorksheetCreateInput!): Worksheet!
  updateWorksheet(data: WorksheetUpdateInput!, where: WorksheetWhereUniqueInput!): Worksheet
  updateManyWorksheets(data: WorksheetUpdateManyMutationInput!, where: WorksheetWhereInput): BatchPayload!
  upsertWorksheet(where: WorksheetWhereUniqueInput!, create: WorksheetCreateInput!, update: WorksheetUpdateInput!): Worksheet!
  deleteWorksheet(where: WorksheetWhereUniqueInput!): Worksheet
  deleteManyWorksheets(where: WorksheetWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum Permission {
  ADMIN
  USER
}

type Product {
  id: ID!
  template: ProductTemplate!
  fields(where: ProductDataWhereInput, orderBy: ProductDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductData!]
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  template: ProductTemplateCreateOneInput!
  fields: ProductDataCreateManyInput
}

input ProductCreateManyInput {
  create: [ProductCreateInput!]
  connect: [ProductWhereUniqueInput!]
}

type ProductData {
  id: ID!
  field: ProductField!
  value: String
}

type ProductDataConnection {
  pageInfo: PageInfo!
  edges: [ProductDataEdge]!
  aggregate: AggregateProductData!
}

input ProductDataCreateInput {
  field: ProductFieldCreateOneInput!
  value: String
}

input ProductDataCreateManyInput {
  create: [ProductDataCreateInput!]
  connect: [ProductDataWhereUniqueInput!]
}

type ProductDataEdge {
  node: ProductData!
  cursor: String!
}

enum ProductDataOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductDataPreviousValues {
  id: ID!
  value: String
}

input ProductDataScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [ProductDataScalarWhereInput!]
  OR: [ProductDataScalarWhereInput!]
  NOT: [ProductDataScalarWhereInput!]
}

type ProductDataSubscriptionPayload {
  mutation: MutationType!
  node: ProductData
  updatedFields: [String!]
  previousValues: ProductDataPreviousValues
}

input ProductDataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductDataWhereInput
  AND: [ProductDataSubscriptionWhereInput!]
  OR: [ProductDataSubscriptionWhereInput!]
  NOT: [ProductDataSubscriptionWhereInput!]
}

input ProductDataUpdateDataInput {
  field: ProductFieldUpdateOneRequiredInput
  value: String
}

input ProductDataUpdateInput {
  field: ProductFieldUpdateOneRequiredInput
  value: String
}

input ProductDataUpdateManyDataInput {
  value: String
}

input ProductDataUpdateManyInput {
  create: [ProductDataCreateInput!]
  update: [ProductDataUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductDataUpsertWithWhereUniqueNestedInput!]
  delete: [ProductDataWhereUniqueInput!]
  connect: [ProductDataWhereUniqueInput!]
  disconnect: [ProductDataWhereUniqueInput!]
  deleteMany: [ProductDataScalarWhereInput!]
  updateMany: [ProductDataUpdateManyWithWhereNestedInput!]
}

input ProductDataUpdateManyMutationInput {
  value: String
}

input ProductDataUpdateManyWithWhereNestedInput {
  where: ProductDataScalarWhereInput!
  data: ProductDataUpdateManyDataInput!
}

input ProductDataUpdateWithWhereUniqueNestedInput {
  where: ProductDataWhereUniqueInput!
  data: ProductDataUpdateDataInput!
}

input ProductDataUpsertWithWhereUniqueNestedInput {
  where: ProductDataWhereUniqueInput!
  update: ProductDataUpdateDataInput!
  create: ProductDataCreateInput!
}

input ProductDataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: ProductFieldWhereInput
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [ProductDataWhereInput!]
  OR: [ProductDataWhereInput!]
  NOT: [ProductDataWhereInput!]
}

input ProductDataWhereUniqueInput {
  id: ID
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type ProductField {
  id: ID!
  type: String!
  name: String!
  default: String
  suffix: String
  role: Job
  required: Int
}

type ProductFieldConnection {
  pageInfo: PageInfo!
  edges: [ProductFieldEdge]!
  aggregate: AggregateProductField!
}

input ProductFieldCreateInput {
  type: String!
  name: String!
  default: String
  suffix: String
  role: Job
  required: Int
}

input ProductFieldCreateManyInput {
  create: [ProductFieldCreateInput!]
  connect: [ProductFieldWhereUniqueInput!]
}

input ProductFieldCreateOneInput {
  create: ProductFieldCreateInput
  connect: ProductFieldWhereUniqueInput
}

type ProductFieldEdge {
  node: ProductField!
  cursor: String!
}

enum ProductFieldOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  default_ASC
  default_DESC
  suffix_ASC
  suffix_DESC
  role_ASC
  role_DESC
  required_ASC
  required_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductFieldPreviousValues {
  id: ID!
  type: String!
  name: String!
  default: String
  suffix: String
  role: Job
  required: Int
}

input ProductFieldScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  default: String
  default_not: String
  default_in: [String!]
  default_not_in: [String!]
  default_lt: String
  default_lte: String
  default_gt: String
  default_gte: String
  default_contains: String
  default_not_contains: String
  default_starts_with: String
  default_not_starts_with: String
  default_ends_with: String
  default_not_ends_with: String
  suffix: String
  suffix_not: String
  suffix_in: [String!]
  suffix_not_in: [String!]
  suffix_lt: String
  suffix_lte: String
  suffix_gt: String
  suffix_gte: String
  suffix_contains: String
  suffix_not_contains: String
  suffix_starts_with: String
  suffix_not_starts_with: String
  suffix_ends_with: String
  suffix_not_ends_with: String
  role: Job
  role_not: Job
  role_in: [Job!]
  role_not_in: [Job!]
  required: Int
  required_not: Int
  required_in: [Int!]
  required_not_in: [Int!]
  required_lt: Int
  required_lte: Int
  required_gt: Int
  required_gte: Int
  AND: [ProductFieldScalarWhereInput!]
  OR: [ProductFieldScalarWhereInput!]
  NOT: [ProductFieldScalarWhereInput!]
}

type ProductFieldSubscriptionPayload {
  mutation: MutationType!
  node: ProductField
  updatedFields: [String!]
  previousValues: ProductFieldPreviousValues
}

input ProductFieldSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductFieldWhereInput
  AND: [ProductFieldSubscriptionWhereInput!]
  OR: [ProductFieldSubscriptionWhereInput!]
  NOT: [ProductFieldSubscriptionWhereInput!]
}

input ProductFieldUpdateDataInput {
  type: String
  name: String
  default: String
  suffix: String
  role: Job
  required: Int
}

input ProductFieldUpdateInput {
  type: String
  name: String
  default: String
  suffix: String
  role: Job
  required: Int
}

input ProductFieldUpdateManyDataInput {
  type: String
  name: String
  default: String
  suffix: String
  role: Job
  required: Int
}

input ProductFieldUpdateManyInput {
  create: [ProductFieldCreateInput!]
  update: [ProductFieldUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductFieldUpsertWithWhereUniqueNestedInput!]
  delete: [ProductFieldWhereUniqueInput!]
  connect: [ProductFieldWhereUniqueInput!]
  disconnect: [ProductFieldWhereUniqueInput!]
  deleteMany: [ProductFieldScalarWhereInput!]
  updateMany: [ProductFieldUpdateManyWithWhereNestedInput!]
}

input ProductFieldUpdateManyMutationInput {
  type: String
  name: String
  default: String
  suffix: String
  role: Job
  required: Int
}

input ProductFieldUpdateManyWithWhereNestedInput {
  where: ProductFieldScalarWhereInput!
  data: ProductFieldUpdateManyDataInput!
}

input ProductFieldUpdateOneRequiredInput {
  create: ProductFieldCreateInput
  update: ProductFieldUpdateDataInput
  upsert: ProductFieldUpsertNestedInput
  connect: ProductFieldWhereUniqueInput
}

input ProductFieldUpdateWithWhereUniqueNestedInput {
  where: ProductFieldWhereUniqueInput!
  data: ProductFieldUpdateDataInput!
}

input ProductFieldUpsertNestedInput {
  update: ProductFieldUpdateDataInput!
  create: ProductFieldCreateInput!
}

input ProductFieldUpsertWithWhereUniqueNestedInput {
  where: ProductFieldWhereUniqueInput!
  update: ProductFieldUpdateDataInput!
  create: ProductFieldCreateInput!
}

input ProductFieldWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  default: String
  default_not: String
  default_in: [String!]
  default_not_in: [String!]
  default_lt: String
  default_lte: String
  default_gt: String
  default_gte: String
  default_contains: String
  default_not_contains: String
  default_starts_with: String
  default_not_starts_with: String
  default_ends_with: String
  default_not_ends_with: String
  suffix: String
  suffix_not: String
  suffix_in: [String!]
  suffix_not_in: [String!]
  suffix_lt: String
  suffix_lte: String
  suffix_gt: String
  suffix_gte: String
  suffix_contains: String
  suffix_not_contains: String
  suffix_starts_with: String
  suffix_not_starts_with: String
  suffix_ends_with: String
  suffix_not_ends_with: String
  role: Job
  role_not: Job
  role_in: [Job!]
  role_not_in: [Job!]
  required: Int
  required_not: Int
  required_in: [Int!]
  required_not_in: [Int!]
  required_lt: Int
  required_lte: Int
  required_gt: Int
  required_gte: Int
  AND: [ProductFieldWhereInput!]
  OR: [ProductFieldWhereInput!]
  NOT: [ProductFieldWhereInput!]
}

input ProductFieldWhereUniqueInput {
  id: ID
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

type ProductTemplate {
  id: ID!
  name: String!
  owner: User!
  status: Int
  fields(where: ProductFieldWhereInput, orderBy: ProductFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductField!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductTemplateConnection {
  pageInfo: PageInfo!
  edges: [ProductTemplateEdge]!
  aggregate: AggregateProductTemplate!
}

input ProductTemplateCreateInput {
  name: String!
  owner: UserCreateOneInput!
  status: Int
  fields: ProductFieldCreateManyInput
}

input ProductTemplateCreateOneInput {
  create: ProductTemplateCreateInput
  connect: ProductTemplateWhereUniqueInput
}

type ProductTemplateEdge {
  node: ProductTemplate!
  cursor: String!
}

enum ProductTemplateOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductTemplatePreviousValues {
  id: ID!
  name: String!
  status: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductTemplateSubscriptionPayload {
  mutation: MutationType!
  node: ProductTemplate
  updatedFields: [String!]
  previousValues: ProductTemplatePreviousValues
}

input ProductTemplateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductTemplateWhereInput
  AND: [ProductTemplateSubscriptionWhereInput!]
  OR: [ProductTemplateSubscriptionWhereInput!]
  NOT: [ProductTemplateSubscriptionWhereInput!]
}

input ProductTemplateUpdateDataInput {
  name: String
  owner: UserUpdateOneRequiredInput
  status: Int
  fields: ProductFieldUpdateManyInput
}

input ProductTemplateUpdateInput {
  name: String
  owner: UserUpdateOneRequiredInput
  status: Int
  fields: ProductFieldUpdateManyInput
}

input ProductTemplateUpdateManyMutationInput {
  name: String
  status: Int
}

input ProductTemplateUpdateOneRequiredInput {
  create: ProductTemplateCreateInput
  update: ProductTemplateUpdateDataInput
  upsert: ProductTemplateUpsertNestedInput
  connect: ProductTemplateWhereUniqueInput
}

input ProductTemplateUpsertNestedInput {
  update: ProductTemplateUpdateDataInput!
  create: ProductTemplateCreateInput!
}

input ProductTemplateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  owner: UserWhereInput
  status: Int
  status_not: Int
  status_in: [Int!]
  status_not_in: [Int!]
  status_lt: Int
  status_lte: Int
  status_gt: Int
  status_gte: Int
  fields_every: ProductFieldWhereInput
  fields_some: ProductFieldWhereInput
  fields_none: ProductFieldWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductTemplateWhereInput!]
  OR: [ProductTemplateWhereInput!]
  NOT: [ProductTemplateWhereInput!]
}

input ProductTemplateWhereUniqueInput {
  id: ID
}

input ProductUpdateDataInput {
  template: ProductTemplateUpdateOneRequiredInput
  fields: ProductDataUpdateManyInput
}

input ProductUpdateInput {
  template: ProductTemplateUpdateOneRequiredInput
  fields: ProductDataUpdateManyInput
}

input ProductUpdateManyInput {
  create: [ProductCreateInput!]
  update: [ProductUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductUpsertWithWhereUniqueNestedInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
}

input ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateDataInput!
}

input ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  template: ProductTemplateWhereInput
  fields_every: ProductDataWhereInput
  fields_some: ProductDataWhereInput
  fields_none: ProductDataWhereInput
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productData(where: ProductDataWhereUniqueInput!): ProductData
  productDatas(where: ProductDataWhereInput, orderBy: ProductDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductData]!
  productDatasConnection(where: ProductDataWhereInput, orderBy: ProductDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductDataConnection!
  productField(where: ProductFieldWhereUniqueInput!): ProductField
  productFields(where: ProductFieldWhereInput, orderBy: ProductFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductField]!
  productFieldsConnection(where: ProductFieldWhereInput, orderBy: ProductFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductFieldConnection!
  productTemplate(where: ProductTemplateWhereUniqueInput!): ProductTemplate
  productTemplates(where: ProductTemplateWhereInput, orderBy: ProductTemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductTemplate]!
  productTemplatesConnection(where: ProductTemplateWhereInput, orderBy: ProductTemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductTemplateConnection!
  stockCategory(where: StockCategoryWhereUniqueInput!): StockCategory
  stockCategories(where: StockCategoryWhereInput, orderBy: StockCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockCategory]!
  stockCategoriesConnection(where: StockCategoryWhereInput, orderBy: StockCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockCategoryConnection!
  stockItem(where: StockItemWhereUniqueInput!): StockItem
  stockItems(where: StockItemWhereInput, orderBy: StockItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockItem]!
  stockItemsConnection(where: StockItemWhereInput, orderBy: StockItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockItemConnection!
  supplier(where: SupplierWhereUniqueInput!): Supplier
  suppliers(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Supplier]!
  suppliersConnection(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SupplierConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  worksheet(where: WorksheetWhereUniqueInput!): Worksheet
  worksheets(where: WorksheetWhereInput, orderBy: WorksheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Worksheet]!
  worksheetsConnection(where: WorksheetWhereInput, orderBy: WorksheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorksheetConnection!
  node(id: ID!): Node
}

enum Status {
  INVOICE
  FRONTOFFICE
  SALES
  GRAPHICDESIGNER
  OPERATOR
  DECOR
  SUPPLIER
  ARCHIVE
}

type StockCategory {
  id: ID!
  name: String
  parent: StockCategory
}

type StockCategoryConnection {
  pageInfo: PageInfo!
  edges: [StockCategoryEdge]!
  aggregate: AggregateStockCategory!
}

input StockCategoryCreateInput {
  name: String
  parent: StockCategoryCreateOneWithoutParentInput
}

input StockCategoryCreateOneInput {
  create: StockCategoryCreateInput
  connect: StockCategoryWhereUniqueInput
}

input StockCategoryCreateOneWithoutParentInput {
  create: StockCategoryCreateWithoutParentInput
  connect: StockCategoryWhereUniqueInput
}

input StockCategoryCreateWithoutParentInput {
  name: String
}

type StockCategoryEdge {
  node: StockCategory!
  cursor: String!
}

enum StockCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StockCategoryPreviousValues {
  id: ID!
  name: String
}

type StockCategorySubscriptionPayload {
  mutation: MutationType!
  node: StockCategory
  updatedFields: [String!]
  previousValues: StockCategoryPreviousValues
}

input StockCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockCategoryWhereInput
  AND: [StockCategorySubscriptionWhereInput!]
  OR: [StockCategorySubscriptionWhereInput!]
  NOT: [StockCategorySubscriptionWhereInput!]
}

input StockCategoryUpdateDataInput {
  name: String
  parent: StockCategoryUpdateOneWithoutParentInput
}

input StockCategoryUpdateInput {
  name: String
  parent: StockCategoryUpdateOneWithoutParentInput
}

input StockCategoryUpdateManyMutationInput {
  name: String
}

input StockCategoryUpdateOneRequiredInput {
  create: StockCategoryCreateInput
  update: StockCategoryUpdateDataInput
  upsert: StockCategoryUpsertNestedInput
  connect: StockCategoryWhereUniqueInput
}

input StockCategoryUpdateOneWithoutParentInput {
  create: StockCategoryCreateWithoutParentInput
  update: StockCategoryUpdateWithoutParentDataInput
  upsert: StockCategoryUpsertWithoutParentInput
  delete: Boolean
  disconnect: Boolean
  connect: StockCategoryWhereUniqueInput
}

input StockCategoryUpdateWithoutParentDataInput {
  name: String
}

input StockCategoryUpsertNestedInput {
  update: StockCategoryUpdateDataInput!
  create: StockCategoryCreateInput!
}

input StockCategoryUpsertWithoutParentInput {
  update: StockCategoryUpdateWithoutParentDataInput!
  create: StockCategoryCreateWithoutParentInput!
}

input StockCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  parent: StockCategoryWhereInput
  AND: [StockCategoryWhereInput!]
  OR: [StockCategoryWhereInput!]
  NOT: [StockCategoryWhereInput!]
}

input StockCategoryWhereUniqueInput {
  id: ID
}

type StockItem {
  id: ID!
  name: String
  category: StockCategory!
  quantity: Int
  quantityUnit: String
  quantityAlarm: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StockItemConnection {
  pageInfo: PageInfo!
  edges: [StockItemEdge]!
  aggregate: AggregateStockItem!
}

input StockItemCreateInput {
  name: String
  category: StockCategoryCreateOneInput!
  quantity: Int
  quantityUnit: String
  quantityAlarm: Int
}

type StockItemEdge {
  node: StockItem!
  cursor: String!
}

enum StockItemOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  quantity_ASC
  quantity_DESC
  quantityUnit_ASC
  quantityUnit_DESC
  quantityAlarm_ASC
  quantityAlarm_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StockItemPreviousValues {
  id: ID!
  name: String
  quantity: Int
  quantityUnit: String
  quantityAlarm: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StockItemSubscriptionPayload {
  mutation: MutationType!
  node: StockItem
  updatedFields: [String!]
  previousValues: StockItemPreviousValues
}

input StockItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockItemWhereInput
  AND: [StockItemSubscriptionWhereInput!]
  OR: [StockItemSubscriptionWhereInput!]
  NOT: [StockItemSubscriptionWhereInput!]
}

input StockItemUpdateInput {
  name: String
  category: StockCategoryUpdateOneRequiredInput
  quantity: Int
  quantityUnit: String
  quantityAlarm: Int
}

input StockItemUpdateManyMutationInput {
  name: String
  quantity: Int
  quantityUnit: String
  quantityAlarm: Int
}

input StockItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: StockCategoryWhereInput
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  quantityUnit: String
  quantityUnit_not: String
  quantityUnit_in: [String!]
  quantityUnit_not_in: [String!]
  quantityUnit_lt: String
  quantityUnit_lte: String
  quantityUnit_gt: String
  quantityUnit_gte: String
  quantityUnit_contains: String
  quantityUnit_not_contains: String
  quantityUnit_starts_with: String
  quantityUnit_not_starts_with: String
  quantityUnit_ends_with: String
  quantityUnit_not_ends_with: String
  quantityAlarm: Int
  quantityAlarm_not: Int
  quantityAlarm_in: [Int!]
  quantityAlarm_not_in: [Int!]
  quantityAlarm_lt: Int
  quantityAlarm_lte: Int
  quantityAlarm_gt: Int
  quantityAlarm_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StockItemWhereInput!]
  OR: [StockItemWhereInput!]
  NOT: [StockItemWhereInput!]
}

input StockItemWhereUniqueInput {
  id: ID
}

type Subscription {
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productData(where: ProductDataSubscriptionWhereInput): ProductDataSubscriptionPayload
  productField(where: ProductFieldSubscriptionWhereInput): ProductFieldSubscriptionPayload
  productTemplate(where: ProductTemplateSubscriptionWhereInput): ProductTemplateSubscriptionPayload
  stockCategory(where: StockCategorySubscriptionWhereInput): StockCategorySubscriptionPayload
  stockItem(where: StockItemSubscriptionWhereInput): StockItemSubscriptionPayload
  supplier(where: SupplierSubscriptionWhereInput): SupplierSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  worksheet(where: WorksheetSubscriptionWhereInput): WorksheetSubscriptionPayload
}

type Supplier {
  id: ID!
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  web: String
  profile: String
}

type SupplierConnection {
  pageInfo: PageInfo!
  edges: [SupplierEdge]!
  aggregate: AggregateSupplier!
}

input SupplierCreateInput {
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  web: String
  profile: String
}

type SupplierEdge {
  node: Supplier!
  cursor: String!
}

enum SupplierOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  contactName_ASC
  contactName_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  address_ASC
  address_DESC
  web_ASC
  web_DESC
  profile_ASC
  profile_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SupplierPreviousValues {
  id: ID!
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  web: String
  profile: String
}

type SupplierSubscriptionPayload {
  mutation: MutationType!
  node: Supplier
  updatedFields: [String!]
  previousValues: SupplierPreviousValues
}

input SupplierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SupplierWhereInput
  AND: [SupplierSubscriptionWhereInput!]
  OR: [SupplierSubscriptionWhereInput!]
  NOT: [SupplierSubscriptionWhereInput!]
}

input SupplierUpdateInput {
  name: String
  contactName: String
  email: String
  phone: String
  address: String
  web: String
  profile: String
}

input SupplierUpdateManyMutationInput {
  name: String
  contactName: String
  email: String
  phone: String
  address: String
  web: String
  profile: String
}

input SupplierWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  contactName: String
  contactName_not: String
  contactName_in: [String!]
  contactName_not_in: [String!]
  contactName_lt: String
  contactName_lte: String
  contactName_gt: String
  contactName_gte: String
  contactName_contains: String
  contactName_not_contains: String
  contactName_starts_with: String
  contactName_not_starts_with: String
  contactName_ends_with: String
  contactName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  web: String
  web_not: String
  web_in: [String!]
  web_not_in: [String!]
  web_lt: String
  web_lte: String
  web_gt: String
  web_gte: String
  web_contains: String
  web_not_contains: String
  web_starts_with: String
  web_not_starts_with: String
  web_ends_with: String
  web_not_ends_with: String
  profile: String
  profile_not: String
  profile_in: [String!]
  profile_not_in: [String!]
  profile_lt: String
  profile_lte: String
  profile_gt: String
  profile_gte: String
  profile_contains: String
  profile_not_contains: String
  profile_starts_with: String
  profile_not_starts_with: String
  profile_ends_with: String
  profile_not_ends_with: String
  AND: [SupplierWhereInput!]
  OR: [SupplierWhereInput!]
  NOT: [SupplierWhereInput!]
}

input SupplierWhereUniqueInput {
  id: ID
}

type Tag {
  id: ID!
  name: String!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  name: String!
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TagPreviousValues {
  id: ID!
  name: String!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  name: String
}

input TagUpdateInput {
  name: String
}

input TagUpdateManyDataInput {
  name: String
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  name: String
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  lastName: String!
  firstName: String!
  email: String!
  phone: String
  avatar: String
  location: String
  job: [Job!]!
  bloodType: String
  ICEName: String
  ICEContact: String
  password: String!
  resetToken: String
  resetTokenExpiry: Float
  permissions: [Permission!]!
  status: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  lastName: String!
  firstName: String!
  email: String!
  phone: String
  avatar: String
  location: String
  job: UserCreatejobInput
  bloodType: String
  ICEName: String
  ICEContact: String
  password: String!
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserCreatepermissionsInput
  status: Boolean
}

input UserCreatejobInput {
  set: [Job!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreatepermissionsInput {
  set: [Permission!]
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  firstName_ASC
  firstName_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  avatar_ASC
  avatar_DESC
  location_ASC
  location_DESC
  bloodType_ASC
  bloodType_DESC
  ICEName_ASC
  ICEName_DESC
  ICEContact_ASC
  ICEContact_DESC
  password_ASC
  password_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  lastName: String!
  firstName: String!
  email: String!
  phone: String
  avatar: String
  location: String
  job: [Job!]!
  bloodType: String
  ICEName: String
  ICEContact: String
  password: String!
  resetToken: String
  resetTokenExpiry: Float
  permissions: [Permission!]!
  status: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  lastName: String
  firstName: String
  email: String
  phone: String
  avatar: String
  location: String
  job: UserUpdatejobInput
  bloodType: String
  ICEName: String
  ICEContact: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  status: Boolean
}

input UserUpdateInput {
  lastName: String
  firstName: String
  email: String
  phone: String
  avatar: String
  location: String
  job: UserUpdatejobInput
  bloodType: String
  ICEName: String
  ICEContact: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  status: Boolean
}

input UserUpdatejobInput {
  set: [Job!]
}

input UserUpdateManyMutationInput {
  lastName: String
  firstName: String
  email: String
  phone: String
  avatar: String
  location: String
  job: UserUpdatejobInput
  bloodType: String
  ICEName: String
  ICEContact: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  status: Boolean
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdatepermissionsInput {
  set: [Permission!]
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  bloodType: String
  bloodType_not: String
  bloodType_in: [String!]
  bloodType_not_in: [String!]
  bloodType_lt: String
  bloodType_lte: String
  bloodType_gt: String
  bloodType_gte: String
  bloodType_contains: String
  bloodType_not_contains: String
  bloodType_starts_with: String
  bloodType_not_starts_with: String
  bloodType_ends_with: String
  bloodType_not_ends_with: String
  ICEName: String
  ICEName_not: String
  ICEName_in: [String!]
  ICEName_not_in: [String!]
  ICEName_lt: String
  ICEName_lte: String
  ICEName_gt: String
  ICEName_gte: String
  ICEName_contains: String
  ICEName_not_contains: String
  ICEName_starts_with: String
  ICEName_not_starts_with: String
  ICEName_ends_with: String
  ICEName_not_ends_with: String
  ICEContact: String
  ICEContact_not: String
  ICEContact_in: [String!]
  ICEContact_not_in: [String!]
  ICEContact_lt: String
  ICEContact_lte: String
  ICEContact_gt: String
  ICEContact_gte: String
  ICEContact_contains: String
  ICEContact_not_contains: String
  ICEContact_starts_with: String
  ICEContact_not_starts_with: String
  ICEContact_ends_with: String
  ICEContact_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: Float
  resetTokenExpiry_not: Float
  resetTokenExpiry_in: [Float!]
  resetTokenExpiry_not_in: [Float!]
  resetTokenExpiry_lt: Float
  resetTokenExpiry_lte: Float
  resetTokenExpiry_gt: Float
  resetTokenExpiry_gte: Float
  status: Boolean
  status_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type Worksheet {
  id: ID!
  name: String!
  owner: User!
  customer: Customer!
  status: Status!
  cover: String
  responsible: User!
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type WorksheetConnection {
  pageInfo: PageInfo!
  edges: [WorksheetEdge]!
  aggregate: AggregateWorksheet!
}

input WorksheetCreateInput {
  name: String!
  owner: UserCreateOneInput!
  customer: CustomerCreateOneInput!
  status: Status!
  cover: String
  responsible: UserCreateOneInput!
  tags: TagCreateManyInput
  products: ProductCreateManyInput
}

type WorksheetEdge {
  node: Worksheet!
  cursor: String!
}

enum WorksheetOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  status_ASC
  status_DESC
  cover_ASC
  cover_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WorksheetPreviousValues {
  id: ID!
  name: String!
  status: Status!
  cover: String
}

type WorksheetSubscriptionPayload {
  mutation: MutationType!
  node: Worksheet
  updatedFields: [String!]
  previousValues: WorksheetPreviousValues
}

input WorksheetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorksheetWhereInput
  AND: [WorksheetSubscriptionWhereInput!]
  OR: [WorksheetSubscriptionWhereInput!]
  NOT: [WorksheetSubscriptionWhereInput!]
}

input WorksheetUpdateInput {
  name: String
  owner: UserUpdateOneRequiredInput
  customer: CustomerUpdateOneRequiredInput
  status: Status
  cover: String
  responsible: UserUpdateOneRequiredInput
  tags: TagUpdateManyInput
  products: ProductUpdateManyInput
}

input WorksheetUpdateManyMutationInput {
  name: String
  status: Status
  cover: String
}

input WorksheetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  owner: UserWhereInput
  customer: CustomerWhereInput
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  cover: String
  cover_not: String
  cover_in: [String!]
  cover_not_in: [String!]
  cover_lt: String
  cover_lte: String
  cover_gt: String
  cover_gte: String
  cover_contains: String
  cover_not_contains: String
  cover_starts_with: String
  cover_not_starts_with: String
  cover_ends_with: String
  cover_not_ends_with: String
  responsible: UserWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [WorksheetWhereInput!]
  OR: [WorksheetWhereInput!]
  NOT: [WorksheetWhereInput!]
}

input WorksheetWhereUniqueInput {
  id: ID
}
